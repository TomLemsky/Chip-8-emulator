// TODO: make a function instead of the loop. It takes the state (set of memory, registers,...) and outputs the following state including the program_counter. Then request next instruction with requestAnimationFrame. Use a flag for waiting on keypress,...

var canvas;
var ctx;

var textbox; // for text output
var lazyLog = [];

// RAM: 0x000 (0) to 0xFFF (4095)
// 0x000 to 0x1FF are forbidden (used by original interpreter)
var memory = new Array(4096).fill(0);
// programs usually start at 0x200
var program_counter = 0x200;
// stack pointer, points to top of stack
var stack_pointer;
// the stack used for return addresses
var stack = new Array(16).fill(0);
// Registers V0 to VF (VF is used as flag)
var registers = new Array(8).fill(0);
// 16-bit I register, for memory addresses (lowest 12 bit)
var i_register = 0;

// delay register, counts down seconds since delay was called
var delay_register = 0;
// sound register, counts down seconds sound will be on
var sound_register = 0;

var wait_for_keypress = false;
var key_register;

var screen_width = 128;
var screen_height = 64;

var screen = Array(screen_height).fill(null).map(() => Array(screen_width).fill(true));

// Keymap: "1234 qwer asdf yxcv"
var keymap = [49,50,51,52,81,87,69,82,65,83,68,70,89,88,67,86];

function decrementTimers(){
	if(delay_register>0){
		delay_register -= 1;
	}

	if(sound_register>0){
		sound_register -= 1;
		// TODO: buzzer sound
	}
}

// keeps track of pressed buttons
var pressed_keys = {}; // You could also use an array
onkeydown = onkeyup = function(e){
    e = e || event; // to deal with IE
    pressed_keys[e.keyCode] = e.type == 'keydown';

    customLog("Pressed: ", e.keyCode);

    if(e.keyCode == 32 && e.type == 'keydown'){ // space bar
        if(wait_for_keypress){
            loop();
        }
        wait_for_keypress = !wait_for_keypress;

        textbox.innerHTML = lazyLog.join("<br>");
    }
	// for the wait on keypress instruction
	if(keymap.includes(e.keyCode) && wait_for_keypress){
        customLog("Trigger keypress");
		key_press = true;
        wait_for_keypress = false;
		last_pressed_key = e.keyCode;
        registers[key_register] = keymap.indexOf(last_pressed_key);
        loop();
	}
}

function sleep(milliseconds) {
 return new Promise(resolve => setTimeout(resolve, milliseconds));
}

var key_press = false;
var last_pressed_key;

function updateDisplay(){
    ctx.clearRect(0, 0, screen_width, screen_height);
	for(let i=0; i < screen_height; i++){
	    for(let j=0; j < screen_width;j++){
			if(screen[i][j]){
				ctx.fillRect(j, i, 1, 1);
			}
	    }
	}
}

function writeToScreen(x,y,sprite){
	var flag = 0; // are pixels erased?
	for(let i=0; i < sprite.length; i++){
	    // loop over bits
	    for(let j=0; j < 8 ; j++){
			var mask = 1 << (7-j);
			var is_bit_set = (sprite[i]&mask)!=0;
			// wrap around to opposite side
			var yy = (y+i) % screen_height;
			var xx = (x+j) % (screen_width/2);

			if(screen[yy][xx] && is_bit_set){
				flag = 1;
			}

			// xor with screen
			screen[yy][xx] ^= is_bit_set;
	    }
	}
	return flag;
}

function clearScreen(){
	ctx.clearRect(0, 0, screen_width, screen_height);
	for(let i=0; i < screen_height; i++){
	    for(let j=0; j < screen_width;j++){
			screen[i][j] = false;
	    }
	}
}

function logInvalidInstruction(bytes){
	customLog("ERROR, invalid instruction: ", bytes[0].toString(16) + bytes[1].toString(16));
}

function initialize(rom){
    // clear RAM, stack, registers
    memory = new Array(4096).fill(0);
    stack = new Array(16).fill(0);
    registers = new Array(8).fill(0);
    delay_register = 0;
    sound_register = 0;

    canvas = document.getElementById('display');
	ctx = canvas.getContext('2d');
	ctx.fillStyle = 'rgb(200, 0, 0)';
	screen[30][10] = false;
	screen[10][11] = true;
	screen[63][127] = true;

	updateDisplay();
	clearScreen();
	// write font data to RAM. (Each character is 5 bytes)
	for(let b=0x0; b<0x10; b++){
		for(let i=0; i<5; i++){
			memory[5*b+i] = font[b][i];
		}
	}

	for(let i=0; i< 0x10; i++){
		writeToScreen(80+5*i,30,memory.slice(5*i,5*i+5));
	}

    updateDisplay();
	clearScreen();

	//var rom = test_rom;
	// load program to memory (programs start at 0x200)
	for(let i=0; i<rom.length; i++){
		memory[0x200+i] = rom[i];
	}



	// start the timers

	//setInterval(decrementTimers(), 1000/60);
}

function nextInstruction(){

		if(stop){
			return;
		}
		// instructions are two bytes long
		var instr_bytes = [memory[program_counter],memory[program_counter+1]];
        var full = ("00" + instr_bytes[0].toString(16)).substr(-2)
            full +=("00" + instr_bytes[1].toString(16)).substr(-2)
		customLog("Instr "+ full + ": (pc: " + program_counter.toString() + ")");
		// nibble = 4 bits (1 hex digit)
		var instr_nibbles = [instr_bytes[0] >> 4, // highest nibble (0xF000)
				             instr_bytes[0] & 0x0F,  // 0x0F00
							 instr_bytes[1] >> 4,    // 0x00F0
							 instr_bytes[1] & 0x0F]; // 0x000F
		// lowest 12 bits
		var nnn = instr_nibbles[1]*0x0100 + instr_bytes[1];
		// lowest 4 bits
		var n = instr_nibbles[3];
		// 2nd nibble
		var x = instr_nibbles[1];
		// 3nd nibble
		var y = instr_nibbles[2];
		// lowest 8 bits
		var kk = instr_bytes[1];

		switch(instr_nibbles[0]){
			case 0x0:
				if(instr_nibbles[1]!=0){
					logInvalidInstruction(instr_bytes);
				}
				if(instr_bytes[1]==0xE0){
					// Clear display
					customLog("CLS");
					clearScreen();
					program_counter += 2;
				} else if (instr_bytes[1]==0xEE){
					// return to address on top of stack
					customLog("RET");
					program_counter = stack.pop()+2;
				} else {
					logInvalidInstruction(instr_bytes);
				}
				break;
			case 0x1:
				// jump to memory adress nnn
				customLog("JP", nnn);

				// prevent infinite loops
				if(program_counter == nnn){
					customLog("Infinite loop detected! Aborting!");
					stop = true;
					return;
				}

				// TODO: are the jumps offset by 0x200 (program start)?
				program_counter = nnn;
				break;
			case 0x2:
				// call subroutine at nnn
				customLog("CALL", nnn);
				stack.push(program_counter);
				program_counter = nnn;
				break;
			case 0x3:
				// skip next instruction if register x equals kk
				customLog("SE",x,kk);
				if(registers[x]==kk){
					program_counter += 4; // skip
				} else {
					program_counter += 2; // don't skip
				}
				break;
			case 0x4:
				// skip next instruction if register x not equal kk
				customLog("SNE",x,kk);
				if(registers[x]!=kk){
					program_counter += 4; // skip
				} else {
					program_counter += 2; // don't skip
				}
				break;
			case 0x5:
				// skip next instruction if registers x and y are equal
				customLog("SE",x,y);

				if(instr_nibbles[3]==0x0){
					logInvalidInstruction(instr_bytes);
				}

				if(registers[x]==registers[y]){
					program_counter += 4; // skip
				} else {
					program_counter += 2; // don't skip
				}
				break;
			case 0x6:
				// put value kk into register x
				customLog("LD",x,kk);
				registers[x] = kk;
				program_counter += 2;
				break;
			case 0x7:
				// add value kk to register x
				customLog("ADD",x,kk);
				registers[x] = (registers[x] + kk) % 0x100;
				program_counter += 2;
				break;
			case 0x8:
				// arithmetic operations don't change pc
				program_counter += 2;
				switch(instr_nibbles[3]){
					case 0x0:
						// copy register y to regsiter x
						customLog("LD",x,y);
						registers[x] = registers[y];
						break;
					case 0x1:
						// bitwise OR on x and y
						customLog("OR",x,y);
						registers[x] = registers[x] | registers[y];
						break;
					case 0x2:
						// bitwise AND on x and y
						customLog("AND",x,y);
						registers[x] = registers[x] & registers[y];
						break;
					case 0x3:
						// bitwise XOR on x and y
						customLog("XOR",x,y);
						registers[x] = registers[x] ^ registers[y];
						break;
					case 0x4:
						// Add x and y
						customLog("ADD",x,y);
						if(registers[x] + registers[y]>255){
							// set carry flag
							registers[0xF] = 1;
						} else {
							registers[0xF] = 0;
						}
						// keep last byte
						registers[x] = (registers[x] + registers[y]) & 0xFF;

						break;
					case 0x5:
						// Subtract y from x
						customLog("SUB",x,y);
						if(registers[x]>registers[y]){
							// set carry flag
							registers[0xF] = 1;
						} else {
							registers[0xF] = 0;
						}
						// TODO: Proper underflow behaviour? Keep last byte?
						registers[x] = (registers[x]-registers[y]) & 0x0FF;

						break;
					case 0x6:
						// SHR x
						customLog("SHR",x,y);
						// if x is even, divide by 2, otherwise set flag
						if(registers[x]%2==0){

							registers[0xF] = 0;
							registers[x] = registers[x]/2;
						} else {
							// set flag
							registers[0xF] = 1;
						}

						break;
					case 0x7:
						// subtract x from y
						customLog("SUBN",x,y);
						// if x is even, divide by 2, otherwise set flag
						if(registers[y]>registers[x]){
							// set flag
							registers[0xF] = 1;
						} else {
							registers[0xF] = 0;
						}
						// TODO: Proper underflow behaviour? Keep last byte?
						registers[x] = (registers[y]-registers[x]) & 0x0FF;

						break;
					case 0xE:
						// SHL x
						customLog("SHL",x,y);
						// is most-significant bit zero?
						if(registers[x] < 0b10000000){
							// set flag
							registers[0xF] = 0;
							registers[x] = registers[x]*2;
						} else {
							registers[0xF] = 1;
						}
						break;
				}
				break;
			case 0x9:
				// skip next instruction if register x and y are not equal
				customLog("SNE",x,y);
				if(instr_nibbles[3]==0x0){
					logInvalidInstruction(instr_bytes);
				}
				if(registers[x]!=registers[y]){
					program_counter += 4;
				} else {
					program_counter += 2;
				}
				break;
			case 0xA:
				// set value of I register to nnn
				customLog("LD",nnn);
				i_register = nnn;
				program_counter += 2;
				break;
			case 0xB:
				// set program counter to nnn plus register 0
				customLog("JP", nnn);
				program_counter = nnn + registers[0];
				break;
			case 0xC:
				// AND rand int with k and store in register x
				customLog("RND",x,kk);
				var random_int = Math.floor(Math.random() * 255);
				registers[x] = random_int & kk;
				program_counter += 2;
				break;
			case 0xD:
				// display n bytes after register I  at x,y
				customLog("DRW",x,y,n, "I_reg: ", i_register);
				var sprite = memory.slice(i_register,i_register+n);
				for(var u = 0; u < n; u++){
					customLog(("00000000" + sprite[u].toString(2)).substr(-8));
				}
				// collission?
				registers[0xF] = writeToScreen(registers[x],registers[y],sprite);
				updateDisplay();
				program_counter += 2;
				break;
			case 0xE:
				switch(instr_bytes[1]){
					case 0x9E:
						// skip next instruction if key corresponding to the value of register x is pressed
						customLog("SKP",x);
						var key_code = keymap[registers[x]];
						if(pressed_keys[key_code]){
							program_counter += 4; // skip next
						} else {
							program_counter += 2; // don't skip
						}
						break;
					case 0xA1:
						customLog("SKNP",x);
						var key_code = keymap[registers[x]];
						if(!pressed_keys[key_code]){
							program_counter += 4; // skip next
						} else {
							program_counter += 2; // don't skip
						}
						break;
					default:
						logInvalidInstruction(instr_bytes);
						break;
				}

				break;
			case 0xF:
				program_counter += 2; // these don't change pc
				switch(instr_bytes[1]){
					case 0x07:
						// store delay timer value in register x
						customLog("LD",x);
						registers[x] = delay_register;
						break;
					case 0x0A:
						// TODO: implement this key press thing (can't just sleep, need to use events)
						// wait for key press, store value in register x
						customLog("LD key");
                        key_register = x;
						key_press = false;
                        wait_for_keypress = true;

                        /*

						while(true){
							if(key_press){
								registers[x] = keymap.indexOf(last_pressed_key);
								break;
							}
						}
                        */
						break;
					case 0x15:
						// set delay timer to val of reg x
						customLog("LD DT", x);
						delay_register = registers[x];
						break;
					case 0x18:
						// set sound timer to val of reg x
						customLog("LD ST", x);
						sound_register = registers[x];
						break;
					case 0x1E:
						// add register x to i register
						customLog("ADD i",y);
						i_register += registers[x];
						break;
					case 0x29:
						// set i register to sprite location for digit val reg x
						// digit sprites are 5 bytes and at start of memory
						customLog("LD F", x);
						i_register = registers[x]*5;
						break;
					case 0x33:
						// story binary coded decimal of register x at I, I+1, I+2
						// hundreds digit
						customLog("LD BCD");
						memory[i_register] = Math.floor(registers[x]/100)%10;
						// tens digit
						memory[i_register+1] = Math.floor(registers[x]/10)%10;
						// ones digit
						memory[i_register+2] = registers[x] % 10;
						break;
					case 0x55:
						// store registers up to x in memory starting at I
						customLog("LD I");
						for(let offset=0; offset <= x; offset++){
							memory[i_register+offset] = registers[offset];
						}
						break;
					case 0x65:
						// load registers up to x from memry starting at I
						customLog("LD I");
						for(let offset=0; offset <= x; offset++){
							registers[offset] = memory[i_register+offset];
						}
						break;
					default:
						logInvalidInstruction(instr_bytes);
						break;
				}
				break;
		}
		//await sleep(0);
}

var stop = false;

function customLog(){
    lazyLog = lazyLog.splice(-100000);
    var s = "";
    for(var i=0; i<arguments.length; i++){
        s += arguments[i].toString() + " ";
    }
    lazyLog.push(s);
}

function loop(){
    // if we are waiting for a keypress, the loop is called later by the keypress event
    if(!wait_for_keypress){

        for(var i=0; i<10;i++){
            decrementTimers();
            nextInstruction();
        }
        window.requestAnimationFrame(loop);
    }
}

window.onload = function(){

    var textbox  = document.getElementById("textbox");

    initialize(picture_rom);

	window.requestAnimationFrame(loop);
    // instruction loop
    //for(var oo=0; oo < 10000; oo++){
    //        nextInstruction();
	//}
	//customLog("Loop ended!");

}



// 4x5 font for digits 0 to F
var font = new Array(16).fill([]);

font[0x0] =
[0b11110000,
 0b10010000,
 0b10010000,
 0b10010000,
 0b11110000];

font[0x1] =
[0b00100000,
 0b01100000,
 0b00100000,
 0b00100000,
 0b01110000];

font[0x2] =
[0b11110000,
 0b00010000,
 0b11110000,
 0b10000000,
 0b11110000];

font[0x3] =
[0b11110000,
 0b00010000,
 0b11110000,
 0b00010000,
 0b11110000];

font[0x4] =
[0b10010000,
 0b10010000,
 0b11110000,
 0b00010000,
 0b00010000];

font[0x5] =
[0b11110000,
 0b10000000,
 0b11110000,
 0b00010000,
 0b11110000];

font[0x6] =
[0b11110000,
 0b10000000,
 0b11110000,
 0b10010000,
 0b11110000];

font[0x7] =
[0b11110000,
 0b00010000,
 0b00100000,
 0b01000000,
 0b01000000];

font[0x8] =
[0b11110000,
 0b10010000,
 0b11110000,
 0b10010000,
 0b11110000];

font[0x9] =
[0b11110000,
 0b10010000,
 0b11110000,
 0b00010000,
 0b11110000];

font[0xA] =
[0b11110000,
 0b10010000,
 0b11110000,
 0b10010000,
 0b10010000];

font[0xB] =
[0b11100000,
 0b10010000,
 0b11100000,
 0b10010000,
 0b11100000];

font[0xC] =
[0b11110000,
 0b10000000,
 0b10000000,
 0b10000000,
 0b11110000];

font[0xD] =
[0b11100000,
 0b10010000,
 0b10010000,
 0b10010000,
 0b11100000];

font[0xE] =
[0b11110000,
 0b10000000,
 0b11110000,
 0b10000000,
 0b11110000];

font[0xF] =
[0b11110000,
 0b10000000,
 0b11110000,
 0b10000000,
 0b10000000];

 var maze_rom = [0xA2, 0x1E, 0xC2, 0x01, 0x32, 0x01, 0xA2, 0x1A, 0xD0, 0x14, 0x70, 0x04, 0x30, 0x40, 0x12, 0x00,
0x60, 0x00, 0x71, 0x04, 0x31, 0x20, 0x12, 0x00, 0x12, 0x18, 0x80, 0x40, 0x20, 0x10, 0x20, 0x40,
0x80, 0x10];

 var pong_rom = [0x6A, 0x02, 0x6B, 0x0C, 0x6C, 0x3F, 0x6D, 0x0C, 0xA2, 0xEA, 0xDA, 0xB6, 0xDC, 0xD6, 0x6E, 0x00,
0x22, 0xD4, 0x66, 0x03, 0x68, 0x02, 0x60, 0x60, 0xF0, 0x15, 0xF0, 0x07, 0x30, 0x00, 0x12, 0x1A,
0xC7, 0x17, 0x77, 0x08, 0x69, 0xFF, 0xA2, 0xF0, 0xD6, 0x71, 0xA2, 0xEA, 0xDA, 0xB6, 0xDC, 0xD6,
0x60, 0x01, 0xE0, 0xA1, 0x7B, 0xFE, 0x60, 0x04, 0xE0, 0xA1, 0x7B, 0x02, 0x60, 0x1F, 0x8B, 0x02,
0xDA, 0xB6, 0x60, 0x0C, 0xE0, 0xA1, 0x7D, 0xFE, 0x60, 0x0D, 0xE0, 0xA1, 0x7D, 0x02, 0x60, 0x1F,
0x8D, 0x02, 0xDC, 0xD6, 0xA2, 0xF0, 0xD6, 0x71, 0x86, 0x84, 0x87, 0x94, 0x60, 0x3F, 0x86, 0x02,
0x61, 0x1F, 0x87, 0x12, 0x46, 0x02, 0x12, 0x78, 0x46, 0x3F, 0x12, 0x82, 0x47, 0x1F, 0x69, 0xFF,
0x47, 0x00, 0x69, 0x01, 0xD6, 0x71, 0x12, 0x2A, 0x68, 0x02, 0x63, 0x01, 0x80, 0x70, 0x80, 0xB5,
0x12, 0x8A, 0x68, 0xFE, 0x63, 0x0A, 0x80, 0x70, 0x80, 0xD5, 0x3F, 0x01, 0x12, 0xA2, 0x61, 0x02,
0x80, 0x15, 0x3F, 0x01, 0x12, 0xBA, 0x80, 0x15, 0x3F, 0x01, 0x12, 0xC8, 0x80, 0x15, 0x3F, 0x01,
0x12, 0xC2, 0x60, 0x20, 0xF0, 0x18, 0x22, 0xD4, 0x8E, 0x34, 0x22, 0xD4, 0x66, 0x3E, 0x33, 0x01,
0x66, 0x03, 0x68, 0xFE, 0x33, 0x01, 0x68, 0x02, 0x12, 0x16, 0x79, 0xFF, 0x49, 0xFE, 0x69, 0xFF,
0x12, 0xC8, 0x79, 0x01, 0x49, 0x02, 0x69, 0x01, 0x60, 0x04, 0xF0, 0x18, 0x76, 0x01, 0x46, 0x40,
0x76, 0xFE, 0x12, 0x6C, 0xA2, 0xF2, 0xFE, 0x33, 0xF2, 0x65, 0xF1, 0x29, 0x64, 0x14, 0x65, 0x00,
0xD4, 0x55, 0x74, 0x15, 0xF2, 0x29, 0xD4, 0x55, 0x00, 0xEE, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
0x80, 0x00, 0x00, 0x00, 0x00, 0x00];

var invaders_rom = [0x12, 0x25, 0x53, 0x50, 0x41, 0x43, 0x45, 0x20, 0x49, 0x4E, 0x56, 0x41, 0x44, 0x45, 0x52, 0x53,
0x20, 0x76, 0x30, 0x2E, 0x39, 0x20, 0x42, 0x79, 0x20, 0x44, 0x61, 0x76, 0x69, 0x64, 0x20, 0x57,
0x49, 0x4E, 0x54, 0x45, 0x52, 0x60, 0x00, 0x61, 0x00, 0x62, 0x08, 0xA3, 0xD3, 0xD0, 0x18, 0x71,
0x08, 0xF2, 0x1E, 0x31, 0x20, 0x12, 0x2D, 0x70, 0x08, 0x61, 0x00, 0x30, 0x40, 0x12, 0x2D, 0x69,
0x05, 0x6C, 0x15, 0x6E, 0x00, 0x23, 0x87, 0x60, 0x0A, 0xF0, 0x15, 0xF0, 0x07, 0x30, 0x00, 0x12,
0x4B, 0x23, 0x87, 0x7E, 0x01, 0x12, 0x45, 0x66, 0x00, 0x68, 0x1C, 0x69, 0x00, 0x6A, 0x04, 0x6B,
0x0A, 0x6C, 0x04, 0x6D, 0x3C, 0x6E, 0x0F, 0x00, 0xE0, 0x23, 0x6B, 0x23, 0x47, 0xFD, 0x15, 0x60,
0x04, 0xE0, 0x9E, 0x12, 0x7D, 0x23, 0x6B, 0x38, 0x00, 0x78, 0xFF, 0x23, 0x6B, 0x60, 0x06, 0xE0,
0x9E, 0x12, 0x8B, 0x23, 0x6B, 0x38, 0x39, 0x78, 0x01, 0x23, 0x6B, 0x36, 0x00, 0x12, 0x9F, 0x60,
0x05, 0xE0, 0x9E, 0x12, 0xE9, 0x66, 0x01, 0x65, 0x1B, 0x84, 0x80, 0xA3, 0xCF, 0xD4, 0x51, 0xA3,
0xCF, 0xD4, 0x51, 0x75, 0xFF, 0x35, 0xFF, 0x12, 0xAD, 0x66, 0x00, 0x12, 0xE9, 0xD4, 0x51, 0x3F,
0x01, 0x12, 0xE9, 0xD4, 0x51, 0x66, 0x00, 0x83, 0x40, 0x73, 0x03, 0x83, 0xB5, 0x62, 0xF8, 0x83,
0x22, 0x62, 0x08, 0x33, 0x00, 0x12, 0xC9, 0x23, 0x73, 0x82, 0x06, 0x43, 0x08, 0x12, 0xD3, 0x33,
0x10, 0x12, 0xD5, 0x23, 0x73, 0x82, 0x06, 0x33, 0x18, 0x12, 0xDD, 0x23, 0x73, 0x82, 0x06, 0x43,
0x20, 0x12, 0xE7, 0x33, 0x28, 0x12, 0xE9, 0x23, 0x73, 0x3E, 0x00, 0x13, 0x07, 0x79, 0x06, 0x49,
0x18, 0x69, 0x00, 0x6A, 0x04, 0x6B, 0x0A, 0x6C, 0x04, 0x7D, 0xF4, 0x6E, 0x0F, 0x00, 0xE0, 0x23,
0x47, 0x23, 0x6B, 0xFD, 0x15, 0x12, 0x6F, 0xF7, 0x07, 0x37, 0x00, 0x12, 0x6F, 0xFD, 0x15, 0x23,
0x47, 0x8B, 0xA4, 0x3B, 0x12, 0x13, 0x1B, 0x7C, 0x02, 0x6A, 0xFC, 0x3B, 0x02, 0x13, 0x23, 0x7C,
0x02, 0x6A, 0x04, 0x23, 0x47, 0x3C, 0x18, 0x12, 0x6F, 0x00, 0xE0, 0xA4, 0xD3, 0x60, 0x14, 0x61,
0x08, 0x62, 0x0F, 0xD0, 0x1F, 0x70, 0x08, 0xF2, 0x1E, 0x30, 0x2C, 0x13, 0x33, 0xF0, 0x0A, 0x00,
0xE0, 0xA6, 0xF4, 0xFE, 0x65, 0x12, 0x25, 0xA3, 0xB7, 0xF9, 0x1E, 0x61, 0x08, 0x23, 0x5F, 0x81,
0x06, 0x23, 0x5F, 0x81, 0x06, 0x23, 0x5F, 0x81, 0x06, 0x23, 0x5F, 0x7B, 0xD0, 0x00, 0xEE, 0x80,
0xE0, 0x80, 0x12, 0x30, 0x00, 0xDB, 0xC6, 0x7B, 0x0C, 0x00, 0xEE, 0xA3, 0xCF, 0x60, 0x1C, 0xD8,
0x04, 0x00, 0xEE, 0x23, 0x47, 0x8E, 0x23, 0x23, 0x47, 0x60, 0x05, 0xF0, 0x18, 0xF0, 0x15, 0xF0,
0x07, 0x30, 0x00, 0x13, 0x7F, 0x00, 0xEE, 0x6A, 0x00, 0x8D, 0xE0, 0x6B, 0x04, 0xE9, 0xA1, 0x12,
0x57, 0xA6, 0x02, 0xFD, 0x1E, 0xF0, 0x65, 0x30, 0xFF, 0x13, 0xA5, 0x6A, 0x00, 0x6B, 0x04, 0x6D,
0x01, 0x6E, 0x01, 0x13, 0x8D, 0xA5, 0x00, 0xF0, 0x1E, 0xDB, 0xC6, 0x7B, 0x08, 0x7D, 0x01, 0x7A,
0x01, 0x3A, 0x07, 0x13, 0x8D, 0x00, 0xEE, 0x3C, 0x7E, 0xFF, 0xFF, 0x99, 0x99, 0x7E, 0xFF, 0xFF,
0x24, 0x24, 0xE7, 0x7E, 0xFF, 0x3C, 0x3C, 0x7E, 0xDB, 0x81, 0x42, 0x3C, 0x7E, 0xFF, 0xDB, 0x10,
0x38, 0x7C, 0xFE, 0x00, 0x00, 0x7F, 0x00, 0x3F, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x3F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3F,
0x08, 0x08, 0xFF, 0x00, 0x00, 0xFE, 0x00, 0xFC, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x7E, 0x42, 0x42,
0x62, 0x62, 0x62, 0x62, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
0x00, 0x00, 0xFF, 0x00, 0x7D, 0x00, 0x41, 0x7D, 0x05, 0x7D, 0x7D, 0x00, 0x00, 0xC2, 0xC2, 0xC6,
0x44, 0x6C, 0x28, 0x38, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
0x00, 0x00, 0xFF, 0x00, 0xF7, 0x10, 0x14, 0xF7, 0xF7, 0x04, 0x04, 0x00, 0x00, 0x7C, 0x44, 0xFE,
0xC2, 0xC2, 0xC2, 0xC2, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
0x00, 0x00, 0xFF, 0x00, 0xEF, 0x20, 0x28, 0xE8, 0xE8, 0x2F, 0x2F, 0x00, 0x00, 0xF9, 0x85, 0xC5,
0xC5, 0xC5, 0xC5, 0xF9, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
0x00, 0x00, 0xFF, 0x00, 0xBE, 0x00, 0x20, 0x30, 0x20, 0xBE, 0xBE, 0x00, 0x00, 0xF7, 0x04, 0xE7,
0x85, 0x85, 0x84, 0xF4, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
0x00, 0x00, 0xFF, 0x00, 0x00, 0x7F, 0x00, 0x3F, 0x00, 0x7F, 0x00, 0x00, 0x00, 0xEF, 0x28, 0xEF,
0x00, 0xE0, 0x60, 0x6F, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
0x00, 0x00, 0xFF, 0x00, 0x00, 0xFE, 0x00, 0xFC, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xC0, 0x00, 0xC0,
0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0xFC, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0xFC,
0x10, 0x10, 0xFF, 0xF9, 0x81, 0xB9, 0x8B, 0x9A, 0x9A, 0xFA, 0x00, 0xFA, 0x8A, 0x9A, 0x9A, 0x9B,
0x99, 0xF8, 0xE6, 0x25, 0x25, 0xF4, 0x34, 0x34, 0x34, 0x00, 0x17, 0x14, 0x34, 0x37, 0x36, 0x26,
0xC7, 0xDF, 0x50, 0x50, 0x5C, 0xD8, 0xD8, 0xDF, 0x00, 0xDF, 0x11, 0x1F, 0x12, 0x1B, 0x19, 0xD9,
0x7C, 0x44, 0xFE, 0x86, 0x86, 0x86, 0xFC, 0x84, 0xFE, 0x82, 0x82, 0xFE, 0xFE, 0x80, 0xC0, 0xC0,
0xC0, 0xFE, 0xFC, 0x82, 0xC2, 0xC2, 0xC2, 0xFC, 0xFE, 0x80, 0xF8, 0xC0, 0xC0, 0xFE, 0xFE, 0x80,
0xF0, 0xC0, 0xC0, 0xC0, 0xFE, 0x80, 0xBE, 0x86, 0x86, 0xFE, 0x86, 0x86, 0xFE, 0x86, 0x86, 0x86,
0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x18, 0x18, 0x18, 0x48, 0x48, 0x78, 0x9C, 0x90, 0xB0, 0xC0,
0xB0, 0x9C, 0x80, 0x80, 0xC0, 0xC0, 0xC0, 0xFE, 0xEE, 0x92, 0x92, 0x86, 0x86, 0x86, 0xFE, 0x82,
0x86, 0x86, 0x86, 0x86, 0x7C, 0x82, 0x86, 0x86, 0x86, 0x7C, 0xFE, 0x82, 0xFE, 0xC0, 0xC0, 0xC0,
0x7C, 0x82, 0xC2, 0xCA, 0xC4, 0x7A, 0xFE, 0x86, 0xFE, 0x90, 0x9C, 0x84, 0xFE, 0xC0, 0xFE, 0x02,
0x02, 0xFE, 0xFE, 0x10, 0x30, 0x30, 0x30, 0x30, 0x82, 0x82, 0xC2, 0xC2, 0xC2, 0xFE, 0x82, 0x82,
0x82, 0xEE, 0x38, 0x10, 0x86, 0x86, 0x96, 0x92, 0x92, 0xEE, 0x82, 0x44, 0x38, 0x38, 0x44, 0x82,
0x82, 0x82, 0xFE, 0x30, 0x30, 0x30, 0xFE, 0x02, 0x1E, 0xF0, 0x80, 0xFE, 0x00, 0x00, 0x00, 0x00,
0x06, 0x06, 0x00, 0x00, 0x00, 0x60, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18,
0x18, 0x18, 0x00, 0x18, 0x7C, 0xC6, 0x0C, 0x18, 0x00, 0x18, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
0xFE, 0x82, 0x86, 0x86, 0x86, 0xFE, 0x08, 0x08, 0x08, 0x18, 0x18, 0x18, 0xFE, 0x02, 0xFE, 0xC0,
0xC0, 0xFE, 0xFE, 0x02, 0x1E, 0x06, 0x06, 0xFE, 0x84, 0xC4, 0xC4, 0xFE, 0x04, 0x04, 0xFE, 0x80,
0xFE, 0x06, 0x06, 0xFE, 0xC0, 0xC0, 0xC0, 0xFE, 0x82, 0xFE, 0xFE, 0x02, 0x02, 0x06, 0x06, 0x06,
0x7C, 0x44, 0xFE, 0x86, 0x86, 0xFE, 0xFE, 0x82, 0xFE, 0x06, 0x06, 0x06, 0x44, 0xFE, 0x44, 0x44,
0xFE, 0x44, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0x6C, 0x5A, 0x00, 0x0C, 0x18, 0xA8, 0x30,
0x4E, 0x7E, 0x00, 0x12, 0x18, 0x66, 0x6C, 0xA8, 0x5A, 0x66, 0x54, 0x24, 0x66, 0x00, 0x48, 0x48,
0x18, 0x12, 0xA8, 0x06, 0x90, 0xA8, 0x12, 0x00, 0x7E, 0x30, 0x12, 0xA8, 0x84, 0x30, 0x4E, 0x72,
0x18, 0x66, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0x90, 0x54, 0x78, 0xA8, 0x48, 0x78, 0x6C, 0x72,
0xA8, 0x12, 0x18, 0x6C, 0x72, 0x66, 0x54, 0x90, 0xA8, 0x72, 0x2A, 0x18, 0xA8, 0x30, 0x4E, 0x7E,
0x00, 0x12, 0x18, 0x66, 0x6C, 0xA8, 0x72, 0x54, 0xA8, 0x5A, 0x66, 0x18, 0x7E, 0x18, 0x4E, 0x72,
0xA8, 0x72, 0x2A, 0x18, 0x30, 0x66, 0xA8, 0x30, 0x4E, 0x7E, 0x00, 0x6C, 0x30, 0x54, 0x4E, 0x9C,
0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0x48, 0x54, 0x7E, 0x18, 0xA8, 0x90, 0x54, 0x78, 0x66,
0xA8, 0x6C, 0x2A, 0x30, 0x5A, 0xA8, 0x84, 0x30, 0x72, 0x2A, 0xA8, 0xD8, 0xA8, 0x00, 0x4E, 0x12,
0xA8, 0xE4, 0xA2, 0xA8, 0x00, 0x4E, 0x12, 0xA8, 0x6C, 0x2A, 0x54, 0x54, 0x72, 0xA8, 0x84, 0x30,
0x72, 0x2A, 0xA8, 0xDE, 0x9C, 0xA8, 0x72, 0x2A, 0x18, 0xA8, 0x0C, 0x54, 0x48, 0x5A, 0x78, 0x72,
0x18, 0x66, 0xA8, 0x72, 0x18, 0x42, 0x42, 0x6C, 0xA8, 0x72, 0x2A, 0x00, 0x72, 0xA8, 0x72, 0x2A,
0x18, 0xA8, 0x30, 0x4E, 0x7E, 0x00, 0x12, 0x18, 0x66, 0x6C, 0xA8, 0x30, 0x4E, 0x0C, 0x66, 0x18,
0x00, 0x6C, 0x18, 0xA8, 0x72, 0x2A, 0x18, 0x30, 0x66, 0xA8, 0x1E, 0x54, 0x66, 0x0C, 0x18, 0x9C,
0xA8, 0x24, 0x54, 0x54, 0x12, 0xA8, 0x42, 0x78, 0x0C, 0x3C, 0xA8, 0xAE, 0xA8, 0xA8, 0xA8, 0xA8,
0xA8, 0xA8, 0xA8, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00];

var tetris_rom = [0xA2, 0xB4, 0x23, 0xE6, 0x22, 0xB6, 0x70, 0x01, 0xD0, 0x11, 0x30, 0x25, 0x12, 0x06, 0x71, 0xFF,
0xD0, 0x11, 0x60, 0x1A, 0xD0, 0x11, 0x60, 0x25, 0x31, 0x00, 0x12, 0x0E, 0xC4, 0x70, 0x44, 0x70,
0x12, 0x1C, 0xC3, 0x03, 0x60, 0x1E, 0x61, 0x03, 0x22, 0x5C, 0xF5, 0x15, 0xD0, 0x14, 0x3F, 0x01,
0x12, 0x3C, 0xD0, 0x14, 0x71, 0xFF, 0xD0, 0x14, 0x23, 0x40, 0x12, 0x1C, 0xE7, 0xA1, 0x22, 0x72,
0xE8, 0xA1, 0x22, 0x84, 0xE9, 0xA1, 0x22, 0x96, 0xE2, 0x9E, 0x12, 0x50, 0x66, 0x00, 0xF6, 0x15,
0xF6, 0x07, 0x36, 0x00, 0x12, 0x3C, 0xD0, 0x14, 0x71, 0x01, 0x12, 0x2A, 0xA2, 0xC4, 0xF4, 0x1E,
0x66, 0x00, 0x43, 0x01, 0x66, 0x04, 0x43, 0x02, 0x66, 0x08, 0x43, 0x03, 0x66, 0x0C, 0xF6, 0x1E,
0x00, 0xEE, 0xD0, 0x14, 0x70, 0xFF, 0x23, 0x34, 0x3F, 0x01, 0x00, 0xEE, 0xD0, 0x14, 0x70, 0x01,
0x23, 0x34, 0x00, 0xEE, 0xD0, 0x14, 0x70, 0x01, 0x23, 0x34, 0x3F, 0x01, 0x00, 0xEE, 0xD0, 0x14,
0x70, 0xFF, 0x23, 0x34, 0x00, 0xEE, 0xD0, 0x14, 0x73, 0x01, 0x43, 0x04, 0x63, 0x00, 0x22, 0x5C,
0x23, 0x34, 0x3F, 0x01, 0x00, 0xEE, 0xD0, 0x14, 0x73, 0xFF, 0x43, 0xFF, 0x63, 0x03, 0x22, 0x5C,
0x23, 0x34, 0x00, 0xEE, 0x80, 0x00, 0x67, 0x05, 0x68, 0x06, 0x69, 0x04, 0x61, 0x1F, 0x65, 0x10,
0x62, 0x07, 0x00, 0xEE, 0x40, 0xE0, 0x00, 0x00, 0x40, 0xC0, 0x40, 0x00, 0x00, 0xE0, 0x40, 0x00,
0x40, 0x60, 0x40, 0x00, 0x40, 0x40, 0x60, 0x00, 0x20, 0xE0, 0x00, 0x00, 0xC0, 0x40, 0x40, 0x00,
0x00, 0xE0, 0x80, 0x00, 0x40, 0x40, 0xC0, 0x00, 0x00, 0xE0, 0x20, 0x00, 0x60, 0x40, 0x40, 0x00,
0x80, 0xE0, 0x00, 0x00, 0x40, 0xC0, 0x80, 0x00, 0xC0, 0x60, 0x00, 0x00, 0x40, 0xC0, 0x80, 0x00,
0xC0, 0x60, 0x00, 0x00, 0x80, 0xC0, 0x40, 0x00, 0x00, 0x60, 0xC0, 0x00, 0x80, 0xC0, 0x40, 0x00,
0x00, 0x60, 0xC0, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00,
0xC0, 0xC0, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x00, 0xF0, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40,
0x00, 0xF0, 0x00, 0x00, 0xD0, 0x14, 0x66, 0x35, 0x76, 0xFF, 0x36, 0x00, 0x13, 0x38, 0x00, 0xEE,
0xA2, 0xB4, 0x8C, 0x10, 0x3C, 0x1E, 0x7C, 0x01, 0x3C, 0x1E, 0x7C, 0x01, 0x3C, 0x1E, 0x7C, 0x01,
0x23, 0x5E, 0x4B, 0x0A, 0x23, 0x72, 0x91, 0xC0, 0x00, 0xEE, 0x71, 0x01, 0x13, 0x50, 0x60, 0x1B,
0x6B, 0x00, 0xD0, 0x11, 0x3F, 0x00, 0x7B, 0x01, 0xD0, 0x11, 0x70, 0x01, 0x30, 0x25, 0x13, 0x62,
0x00, 0xEE, 0x60, 0x1B, 0xD0, 0x11, 0x70, 0x01, 0x30, 0x25, 0x13, 0x74, 0x8E, 0x10, 0x8D, 0xE0,
0x7E, 0xFF, 0x60, 0x1B, 0x6B, 0x00, 0xD0, 0xE1, 0x3F, 0x00, 0x13, 0x90, 0xD0, 0xE1, 0x13, 0x94,
0xD0, 0xD1, 0x7B, 0x01, 0x70, 0x01, 0x30, 0x25, 0x13, 0x86, 0x4B, 0x00, 0x13, 0xA6, 0x7D, 0xFF,
0x7E, 0xFF, 0x3D, 0x01, 0x13, 0x82, 0x23, 0xC0, 0x3F, 0x01, 0x23, 0xC0, 0x7A, 0x01, 0x23, 0xC0,
0x80, 0xA0, 0x6D, 0x07, 0x80, 0xD2, 0x40, 0x04, 0x75, 0xFE, 0x45, 0x02, 0x65, 0x04, 0x00, 0xEE,
0xA7, 0x00, 0xF2, 0x55, 0xA8, 0x04, 0xFA, 0x33, 0xF2, 0x65, 0xF0, 0x29, 0x6D, 0x32, 0x6E, 0x00,
0xDD, 0xE5, 0x7D, 0x05, 0xF1, 0x29, 0xDD, 0xE5, 0x7D, 0x05, 0xF2, 0x29, 0xDD, 0xE5, 0xA7, 0x00,
0xF2, 0x65, 0xA2, 0xB4, 0x00, 0xEE, 0x6A, 0x00, 0x60, 0x19, 0x00, 0xEE, 0x37, 0x23];
